# VERONICA v0.4.0 -- Technical Artifacts

## A. Mermaid Diagrams

### Diagram 1: Static Architecture Layer Diagram

```mermaid
graph TB
    subgraph APP["Application / Orchestrator"]
        A1["Agent loop<br/>(tool selection, prompt assembly)"]
    end

    subgraph VI["VeronicaIntegration"]
        direction TB
        VI1["shield: ShieldConfig | None"]
        VI2["_shield_pipeline: ShieldPipeline | None"]
    end

    subgraph SHIELD["Execution Shield  (v0.4.0)"]
        direction TB

        subgraph CONFIG["Config Layer  [implemented]"]
            SC["ShieldConfig"]
            SC --> SMC["SafeModeConfig"]
            SC --> BC["BudgetConfig"]
            SC --> CBC["CircuitBreakerConfig"]
            SC --> EC["EgressConfig"]
            SC --> SGC["SecretGuardConfig"]
        end

        subgraph TYPES["Type Layer  [implemented]"]
            DEC["Decision enum<br/>ALLOW | RETRY | HALT<br/>DEGRADE | QUARANTINE | QUEUE"]
            TCC["ToolCallContext<br/>(frozen dataclass, 10 fields)"]
        end

        subgraph HOOKS["Hook Layer  [implemented]"]
            direction LR
            H1["PreDispatchHook<br/>(Protocol)"]
            H2["EgressBoundaryHook<br/>(Protocol)"]
            H3["RetryBoundaryHook<br/>(Protocol)"]
            H4["BudgetBoundaryHook<br/>(Protocol)"]
        end

        subgraph PIPELINE["Pipeline  [implemented]"]
            SP["ShieldPipeline<br/>evaluates hook chain<br/>returns Decision"]
            SBE["ShieldBlockedError<br/>(type only -- not raised<br/>by library code)"]
        end

        subgraph SAFEMODE["SafeMode  [implemented]"]
            SMH["SafeModeHook"]
            SMH -->|"implements"| H1
            SMH -->|"implements"| H3
            SMH -.-x|"does NOT<br/>implement"| H2
            SMH -.-x|"does NOT<br/>implement"| H4
        end

        subgraph PLANNED["Planned Hooks  (P0 next)"]
            style PLANNED stroke-dasharray: 5 5
            PH1["BudgetWindowHook<br/>[planned]"]
            PH2["EgressAllowlistHook<br/>[planned]"]
            PH3["SecretGuardHook<br/>[planned]"]
            PH1 -.->|"will implement"| H4
            PH2 -.->|"will implement"| H2
        end
    end

    subgraph CORE["VERONICA Runtime Core  (v0.2.0)"]
        direction LR
        RT["RetryContainer"]
        CB["CircuitBreaker"]
        BE["BudgetEnforcer"]
        ASG["AgentStepGuard"]
        PRB["PartialResultBuffer"]
    end

    subgraph EXT["External Systems"]
        LLM["LLM Provider<br/>(API)"]
        TOOLS["Tools<br/>(exec, http, db)"]
    end

    A1 --> VI
    VI1 --> CONFIG
    VI2 --> PIPELINE
    SP -->|"evaluates"| H1
    SP -->|"evaluates"| H2
    SP -->|"evaluates"| H3
    SP -->|"evaluates"| H4
    VI --> CORE
    CORE --> LLM
    CORE --> TOOLS
```

### Diagram 2: Dynamic Request Flow

```mermaid
sequenceDiagram
    participant App as Application
    participant VI as VeronicaIntegration
    participant SP as ShieldPipeline
    participant SMH as SafeModeHook
    participant Core as Runtime Core
    participant LLM as LLM Provider

    Note over App,LLM: Happy path (shield=None or safe_mode disabled)

    App->>VI: execute tool call
    VI->>SP: before_llm_call(ctx)
    Note right of SP: No hook set OR<br/>hook returns None
    SP-->>VI: Decision.ALLOW
    VI->>Core: proceed with call
    Core->>LLM: API request
    LLM-->>Core: response
    Core-->>App: result

    Note over App,LLM: SafeMode enabled -- tool call blocked

    App->>VI: execute tool call
    VI->>SP: before_llm_call(ctx)
    SP->>SMH: before_llm_call(ctx)
    Note right of SMH: ctx.tool_name != None
    SMH-->>SP: Decision.HALT
    SP-->>VI: Decision.HALT
    Note over VI: Decision.HALT returned.<br/>Consumer code decides<br/>how to handle.
    VI-->>App: HALT (tool dispatch blocked)

    Note over App,LLM: SafeMode enabled -- error retry suppressed

    App->>VI: execute tool call (safe_mode.enabled=False for this call)
    VI->>Core: proceed with call
    Core->>LLM: API request
    LLM-->>Core: error / exception
    Core->>VI: propagate error
    VI->>SP: on_error(ctx, err)
    SP->>SMH: on_error(ctx, err)
    Note right of SMH: enabled=True:<br/>suppress all retries
    SMH-->>SP: Decision.HALT
    SP-->>VI: Decision.HALT
    VI-->>App: HALT (no retry)

    Note over App,LLM: Egress boundary (NOT covered by SafeMode)

    rect rgb(255, 245, 230)
        Note over SP: before_egress(ctx, url, method)
        Note right of SP: No egress hook wired.<br/>Returns Decision.ALLOW.<br/>SafeMode does NOT<br/>intercept egress.
    end

    rect rgb(255, 245, 230)
        Note over SP: before_charge(ctx, cost_usd)
        Note right of SP: No budget hook wired.<br/>Returns Decision.ALLOW.<br/>SafeMode does NOT<br/>intercept charges.
    end
```

### Diagram 3: Shield State Machine (forward-looking)

```mermaid
stateDiagram-v2
    [*] --> NORMAL

    state "NORMAL" as N
    state "WARNING" as W
    state "QUARANTINE" as Q
    state "SAFE_MODE" as SM
    state "HALT" as H

    N --> W : error rate exceeds threshold [planned P1]
    N --> SM : manual flag via ShieldConfig [implemented]
    N --> H : emergency halt [planned P1]

    W --> N : error rate recovers [planned P1]
    W --> Q : repeated failures on same tool [planned P2]
    W --> SM : manual flag [implemented]
    W --> H : budget exhausted [planned P1]

    Q --> W : quarantine timeout expires [planned P2]
    Q --> SM : manual flag [implemented]
    Q --> H : escalation [planned P2]

    SM --> N : manual flag cleared [implemented]
    SM --> H : operator decision [planned P1]

    H --> N : operator restart [planned P1]

    note right of N
        Default state.
        All hooks return None/ALLOW.
        Pass-through behavior.
    end note

    note right of SM
        [IMPLEMENTED]
        SafeModeHook(enabled=True)
        - Blocks tool dispatch (HALT)
        - Suppresses retries (HALT)
        - Does NOT block egress
        - Does NOT block budget
        Manual toggle only.
    end note

    note left of W
        [PLANNED P1]
        Automatic escalation based
        on error rate windowing.
        Requires BudgetWindowHook.
    end note

    note left of Q
        [PLANNED P2]
        Per-tool isolation.
        Blocks specific tool_name
        while allowing others.
    end note

    note right of H
        [PLANNED P1]
        Terminal state.
        All calls return HALT.
        Requires operator restart.
    end note
```

---

## B. Technical Announcement Draft

### Title Options

1. **VERONICA v0.4.0: Execution Shield Foundation -- Typed Boundaries for LLM Agent Failures**
2. **Introducing the VERONICA Execution Shield: Structured Halt Points for Agentic Tool Dispatch**
3. **VERONICA v0.4.0: Why Your LLM Agent Needs a Kill Switch (and How We Built One)**

---

### Announcement

# VERONICA v0.4.0: Execution Shield Foundation

## The problem: deterministic failure loops in LLM agents

LLM agents fail in predictable ways. When an agent calls a tool with
missing arguments, the tool returns an error. The agent retries with
the same missing arguments. The tool returns the same error. This loop
continues until a timeout, a rate limit, or budget exhaustion stops it.

This is a known failure mode. For example, crewAI issue #4495 (March
2025) describes a case where native tool calling bypassed argument
validation, leaving the LLM without schema enforcement feedback. The
result was an infinite retry loop with identical malformed calls -- a
pattern that burned tokens, produced no useful output, and required
manual intervention to stop.

LLM mistakes are expected; the question is whether the runtime
surrounding the LLM has a structured mechanism to detect a loop and
halt it.

VERONICA's existing runtime core (v0.2) addresses individual
primitives -- `RetryContainer`, `CircuitBreaker`, `BudgetEnforcer`,
`AgentStepGuard` -- but these operate independently. There is no
unified interception layer that evaluates a tool call *before* it
reaches the LLM provider, and *after* an error occurs, using
consistent types and a single decision vocabulary.

v0.4.0 introduces that layer.

## What shipped: the Execution Shield foundation

The Execution Shield is a typed hook pipeline that sits between the
application and the runtime core. It intercepts at four boundaries:

| Boundary | Hook Protocol | When evaluated |
|----------|---------------|----------------|
| Pre-dispatch | `PreDispatchHook` | Before every LLM / tool call |
| Egress | `EgressBoundaryHook` | Before outbound HTTP |
| Retry | `RetryBoundaryHook` | When a tool call raises an exception |
| Budget | `BudgetBoundaryHook` | Before recording a cost charge |

Each hook returns a `Decision` -- a six-member `str` enum (`ALLOW`,
`RETRY`, `HALT`, `DEGRADE`, `QUARANTINE`, `QUEUE`) -- or `None` to
defer. The `ShieldPipeline` evaluates each hook and returns `ALLOW` if
no hook has an opinion. This means the default behavior, with no hooks
configured, is complete pass-through. Existing code is unaffected.

The foundation consists of five layers delivered as stacked PRs:

1. **Config layer** (`ShieldConfig` + 5 sub-configs) -- dataclass
   hierarchy, loadable from env vars, JSON, or YAML. All features
   `enabled=False` by default.
2. **Type layer** (`Decision` enum + `ToolCallContext`) -- frozen
   dataclass capturing request ID, tool name, model, token counts,
   cost, and arbitrary metadata.
3. **Hook interfaces** -- four `typing.Protocol` definitions with
   `@runtime_checkable`, plus four noop implementations for testing.
4. **Pipeline skeleton** (`ShieldPipeline` + `ShieldBlockedError`) --
   evaluates the hook chain, returns `Decision`. Stored as
   `VeronicaIntegration._shield_pipeline` for consumer access, with
   zero behavior change when no hooks are set.
5. **SafeMode** (`SafeModeHook`) -- the first concrete hook
   implementation.

The initial foundation is intentionally small and self-contained.
Zero external dependencies. stdlib only.

## SafeMode: what it does and what it does not

SafeMode is an emergency kill switch. When
`ShieldConfig(safe_mode=SafeModeConfig(enabled=True))` is passed to
`VeronicaIntegration`, two things happen:

- **Pre-dispatch**: any call where `ctx.tool_name` is not `None`
  returns `Decision.HALT`. Pure LLM completions (no tool) pass through.
- **Retry boundary**: any error returns `Decision.HALT`. No retries
  are attempted.

What SafeMode does **not** do:

- It does not intercept HTTP egress (`before_egress` has no hook).
- It does not intercept budget charges (`before_charge` has no hook).
- It does not automatically activate. It is a manual flag in the
  config. There is no error-rate windowing or automatic escalation
  today.
- No library code raises `ShieldBlockedError`. The pipeline returns
  a `Decision`; the caller decides how to handle it.
  `ShieldBlockedError` is exported as a convenience type for
  consumer code that wants a structured exception.

This scope is intentional. SafeMode addresses the most immediate
failure mode -- the deterministic retry loop -- while the egress and
budget boundaries require their own hook implementations with
different configuration surfaces.

## Why opt-in and pass-through by default

Every shield feature is disabled by default. `ShieldConfig()` with no
arguments produces a config where `is_any_enabled` returns `False`.
When `shield=None` (the default for `VeronicaIntegration`), no
pipeline is created at all.

This matters because VERONICA is a library, not a framework. Users
who upgrade from v0.2 to v0.4 see no behavior change, no new
exceptions, no new failure modes. They opt in to specific shield
features when they are ready.

The hook protocol design also means users can implement their own
hooks. Any object with the right method signature satisfies the
`Protocol` and can be passed to `ShieldPipeline`. No inheritance,
no registration, no decorators.

## Roadmap: what comes next

The following are the immediate P0 priorities for the shield layer:

- **Budget window hook**: implements `BudgetBoundaryHook`. Tracks
  token/call/cost consumption over a sliding time window.
  Returns `HALT` when a threshold is exceeded. Replaces the
  standalone `BudgetEnforcer` for shield-aware deployments.
- **Egress allowlist hook**: implements `EgressBoundaryHook`.
  Default-deny for outbound HTTP. Allows only hosts listed in
  `EgressConfig.allowed_hosts`.
- **SecretGuard hook**: scans outbound payloads against
  `SecretGuardConfig.patterns` before egress. Returns `QUARANTINE`
  if a credential pattern is detected.

Planned for P1: automatic state transitions (NORMAL -> WARNING ->
HALT) based on error-rate windowing, and integration of
`CircuitBreaker` state with the shield pipeline.

Planned for P2: per-tool quarantine (`QUARANTINE` decision scoped to
a specific `tool_name`) and the `DEGRADE` / `QUEUE` decision
handlers.

## Installation and usage

```python
from veronica_core import VeronicaIntegration
from veronica_core.shield import ShieldConfig, SafeModeConfig

# Default: no shield, no behavior change
vi = VeronicaIntegration()

# With SafeMode enabled
vi = VeronicaIntegration(
    shield=ShieldConfig(safe_mode=SafeModeConfig(enabled=True))
)

# From environment variable: VERONICA_SAFE_MODE=1
vi = VeronicaIntegration(shield=ShieldConfig.from_env())
```

166 tests passing, 4 xfailed (pre-existing). Zero external
dependencies. Python >= 3.9. stdlib only.

---

Apache-2.0. Python >=3.9. No external runtime dependencies.
